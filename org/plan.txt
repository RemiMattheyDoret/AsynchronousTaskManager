ProcessController -> taskCPPController

PredefinedFunctions -> PredefinedTasks

Decide whether AsynchronousTaskManager should be a namespace, a funktor or what.

Allocate ressources and measure ressources of tasks.

Developt the 'outputWriter' class or namespace

improve Command object. Maybe with polymorphism

Ensure start returns the taskID and not only print it... maybe. Dunno.

Ensure process is not duplicated or kept around for nothing.

Put underscores everywhere when needed.

Make sure I do not call a funktor something that is not. A funktor has operator()()

a parameter to a thread is always passed by value! Or use std::ref(s) or std::move(s) or use a pointer.
















main directly calls the AsynchroTaskManager.

AsynchroTaskManager prints helps if needed. And it listens to user inputs in an infinite while loop.

CommandParser interprets the command

TaskBank contains all the tasks with their IDs and status. Tasks are kept in a vector. The ID of the task is thee position in the vector. If offer possibility also to name tasks with command 'rename <ID> <newname>' or better with 'start --name <casual name> --file shellCommand'. Might add reessources too.

Usage

	start --name <casual name> --file shellCommand
	pause <ID|casual name>
	resume <ID|casual name>
	stop <ID|casual name>


Task is the object for a task that is currently running or has finished to run. Task calls system in initializer list. Could also limit and measure ressources.


Use  and place all classes as nested to AsynchronousTaskManager. Task should be nested in TaskBank too.


class AsynchronousTaskManager::Exceptions
{
public:
	enum {processFailed} exceptions;

	std::ostream& operator<<(std::ostream& out, const Errors value){
    const char* s = 0;
	#define PROCESS_VAL(p) case(p): s = #p; break;
	    switch(value){
	        PROCESS_VAL(ErrorA);     
	        PROCESS_VAL(ErrorB);     
	        PROCESS_VAL(ErrorC);
	    }
	#undef PROCESS_VAL

    return out << s << "\n";	
};

class AsynchronousTaskManager::TaskBank::Task
{
	public:
		enum {paused, running, stopped, completed} TaskStatus;

		Task(std::string&& process):{}

	private:
		static unsigned long currentTaskID = 0;

		TaskStatus status;
		const unsigned long taskID;
		// CPUtime
		// RAMusage
};


class AsynchronousTaskManager::TaskBank
{
private:
	class Task;

	std::vector<Task> tasks;
	std::unordered_map<std::string, taskID_t> NamesIDsmap;

};


struct AsynchronousTaskManager::Command
{
	enum {start, pause, resume, stop, status, quit} BaseCommand;

	BaseCommand baseCommand;
	std::string process;
	taskID_t taskID;
	std::string taskName;
};




class AsynchronousTaskManager // Acts as a funktor
{
	public:
		AsynchronousTaskManager():
		{
			/* 
				As AsynchronousTaskManager is used as a funktor, I decided to use taskBank as a method variable and not as a private member of the class. Also, as TaskBank is a nested class, using it as a member variable protects me from having to use the pImpl idiom.

			*/
			TaskBank taskBank; 
			while (true)
			{
				/*
					One loop of this big while loop per process submitted. AsynchronousTaskManager will be ready to listen to the next command only once the process has started, hence protecting us from issues of concurrent access to static members such as 'currentTaskID' in 'class AsynchronousTaskManager::TaskBank::Task'
				*/


				std::string command;
				auto command = parseCommand(readUserInput()); // std::cin or something to read command
				

				switch(command.baseCommand)
				{
					case Command::start:
						TaskID_t taskID = taskBank.start(command.process);
						std::cout << taskID << "\n";
						break;

					case Command::pause:
						if (command.taskName == "")
							taskBank.pause(command.taskID);
						else
							taskBank.pause(command.taskName);
						break;

					case Command::resume:
						if (command.taskName == "")
							taskBank.resume(command.taskID);
						else
							taskBank.resume(command.taskName);
						break;

					case Command::stop:
						if (command.taskName == "")
							taskBank.stop(command.taskID);
						else
							taskBank.stop(command.taskName);
						break;

					case Command::status:
						if (command.taskName == "")
							taskBank.status(command.taskID);
						else
							taskBank.status(command.taskName);
						break;

					case Command::quit:
						taskBank.stopAllTasks();
						return;
						

					default:
						std::cout << "Command::status = " << Command::status << "\n";
						raise ...
				}
			}
		}

	private:
		class TaskBank;
		class Command;


		// This is to ensure the user does not try to call more than one AsynchronousTaskManager operator() at onces. AsynchronousTaskManager needs to be a singleton (if the term applies for a funktor).

		static bool doesInstanceExist = false; 

		Command parseCommand(std::strting& stringCommand)
		{
			return {Command::start, "echo Hello World"};
		}
}






